{
  parserClass="by.home.acs.language.parser.ACSParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  extends("ParenthesisedExpression|BinaryExpression|FunctionInvocation|ArrayReferenceExpression|IncrementOrDecrementExpression|NegationExpression|LiteralExpression")=AssignmentExpression
  extends("DefineParenthesesExpression|DefineBinaryExpression|DefineLiteralExpression")=DefineExpression

  psiClassPrefix="ACScript"
  psiImplClassSuffix="Impl"
  psiPackage="by.home.acs.language.psi"
  psiImplPackage="by.home.acs.language.psi.impl"
  elementTypeFactory="by.home.acs.language.psi.ACSElementType.createTypes"
  elementTypeHolderClass="by.home.acs.language.ACSTypes"
  elementTypeClass="by.home.acs.language.psi.ACSElementType"
  tokenTypeClass="by.home.acs.language.psi.ACSTokenType"

  //psiImplUtilClass="by.home.acs.language.util.psi.ACSBnfPsiImplUtil"
  generate=[tokens="yes"]

  tokens = [
    //REGEXP TOKENS                    
    WHITE_SPACE = 'regexp:\s+'
    NUMBER='regexp:(0[xX][0-9a-fA-F]+)|(-?[0-9]+)'
    STRING = 'regexp:\"([^\\\"]|\\.)*\"'
    IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'  
    
    //KEYWORDS          
    FUNCTION='function'
    SCRIPT='script'
    SPECIAL = 'special'

    //SCRIPT TYPES
    OPEN = 'OPEN'
    ENTER = 'ENTER'
    RETURN = 'RETURN'
    RESPAWN = 'RESPAWN'
    DEATH = 'DEATH'
    LIGHTNING = 'LIGHNTNING'
    UNLOADING = 'UNLOADING'
    DISCONNEC = 'DISCONNECT'
    KILL = 'KILL'
    REOPEN = 'REOPEN'
    PICKUP = 'PICKUP'
    REDRETURN = 'REDRETURN'
    BLUERETURN = 'BLUERETURN'
    WHITERETURN = 'WHITERETURN'

    //VARIABLE TYPES
    VOID = 'void'
    INT = 'int'
    STR = 'str'
    BOOl = 'bool'

    //SYMBOLS
    COMMA = ','
    SEMICOLON = ';'
    COLON = ':'

  ]
}

ACSScriptFile ::= FileContainer

private FileContainer ::= (COMMENT|Definition*)

Definition ::= (FunctionDefinition | ScriptDefinition | DirectivesDeclaration | GlobalModifier | SpecialDefinition | VariableDefinition)


/**
    Specials declaration
 */

SpecialDefinition ::= SPECIAL SpecialExpression SEMICOLON

SpecialExpression ::= (NUMBER COLON FunctionInvocation) (COMMA SpecialExpression)*


FunctionDefinition ::= FUNCTION FunctionReturnType FunctionName FunctionParameters FunctionBody

ScriptDefinition ::= ScriptIdentifier ScriptName (ScriptPossibleParams | ScriptType) (NetType ClientsideType | NetType | ClientsideType)? ScriptBody
/**
    Directives statement
 */
DirectivesDeclaration ::= (IncludeDeclaration | ImportDeclaration | DefineDeclaration | LibraryDeclaration)

IncludeDeclaration ::= IncludeKey STRING

ImportDeclaration ::= ImportKey STRING

DefineDeclaration ::= DefineKey IDENTIFIER  DefineExpression

LibraryDeclaration ::= LibraryKey STRING

/**
    Directives keywords
 */

DefineKey ::= '#define'

IncludeKey ::= '#include'

ImportKey ::= '#import'

LibraryKey ::= '#library'

DefineExpression ::= DefineParenthesesExpression | DefineBinaryExpression | DefineLiteralExpression

DefineParenthesesExpression ::= OpenBracket DefineExpression CloseBracket

DefineBinaryExpression ::= DefineExpression Operator DefineExpression

DefineLiteralExpression ::= NUMBER | FLOAT | STRING | IDENTIFIER //VARIABLE NAME HERE???

/**
    Script statements
 */
ScriptIdentifier ::= SCRIPT

ScriptType ::= OPEN | ENTER | RETURN | RESPAWN | DEATH | LIGHTNING | UNLOADING | DISCONNECT | KILL | REOPEN | PICKUP | REDRETURN | BLUERETURN | WHITERETURN

ScriptName ::= (STRING | NUMBER)

ScriptPossibleParams ::= OpenBracket (ScriptParameterWithVoid | ScriptParameter) CloseBracket

ScriptParameterWithVoid ::=  VoidType

ScriptParameter ::= ScriptParameterList

ScriptParameterList ::= ScriptFormalParameter (COMMA ScriptFormalParameter)*

ScriptFormalParameter ::= INT VariableName

ScriptBody ::= CodeBlock | Statement

/**
    Function statements
 */
FunctionInvocation ::= FunctionName (NormalFunctionInvocation | TypeCastFunctionInvocation | MixedCastFunctionInvocation)

NormalFunctionInvocation ::=  OpenBracket FunctionInvokeParameters* CloseBracket

TypeCastFunctionInvocation ::=  OpenBracket TypeCastFunctionInvokeParameters CloseBracket

MixedCastFunctionInvocation ::=  OpenBracket MixedCastFunctionInvokeParameters CloseBracket

TypeCastFunctionInvokeParameters ::= TypeCast COLON BinaryExpression (COMMA TypeCast COLON BinaryExpression)*

MixedCastFunctionInvokeParameters ::= TypeCast COLON BinaryExpression (COMMA TypeCast COLON BinaryExpression | SEMICOLON FunctionInvokeParameters)*
/**
    TypeCasts parameters. All type cast parameters are case-sensitive. E.g. parameter 'S' instead of 's' will not work
 */
TypeCast ::= TypeCastArray | TypeCastBinary | TypeCastCharacter | TypeCastDecimal
                | TypeCastFixedPointNumber | TypeCastKey | TypeCastLanguage | TypeCastName | TypeCastString | TypeCastHex

TypeCastArray ::= 'a'

TypeCastBinary ::= 'b'

TypeCastCharacter ::= 'c'

TypeCastDecimal ::= 'i' | 'd'

TypeCastFixedPointNumber ::= 'f'

TypeCastKey ::= 'k'

TypeCastLanguage ::= 'l'

TypeCastName ::= 'n'

TypeCastString ::= 's'

TypeCastHex ::= 'h'

FunctionInvokeParameters ::= BinaryExpression (COMMA BinaryExpression)*

FunctionReturnType ::= VOID | Type

FunctionParameterWithVoid ::= VoidType

FunctionName ::= IDENTIFIER
/*{
    mixin="by.home.acs.language.psi.impl.ACSFunctionElementImpl"
    implements="by.home.acs.language.psi.ACSFunctionElement"
    methods=[getName getNameIdentifier changeName getReference]
    stubClass="by.home.acs.language.stub.function.ACSFunctionStub"
}*/


FunctionParameters ::= OpenBracket FunctionParameter CloseBracket

FunctionParameter ::=  (FunctionParameterWithVoid | FunctionParameterList)

FunctionParameterList ::= FunctionFormalParameter (COMMA FunctionFormalParameter)*

FunctionFormalParameter ::= Type VariableName

FunctionBody ::= OpenBrace Statement* CloseBrace

/**

 */

GlobalModifier ::= (global | world) Type NUMBER COLON IDENTIFIER SEMICOLON

StaticModifier ::= static

NetType ::= NET

ClientsideType ::= CLIENTSIDE

VoidType ::= VOID

TerminateKeyword ::= terminate SEMICOLON

SuspendKeyword ::= suspend SEMICOLON

RestartKeyword ::= restart SEMICOLON

Statement ::= (StatementWithoutSub | IncrementOrDecrementExpression SEMICOLON | VariableDefinition | AssignmentStatement | FunctionInvocation SEMICOLON | IfThenElseStatement | IfThenStatement | Loops | SwitchLoop)

StatementWithoutSub ::= (CodeBlock | BreakStatement | ContinueStatement | ReturnOperator | SuspendKeyword | RestartKeyword | TerminateKeyword)

CodeBlock ::= OpenBrace Statement* CloseBrace

BinaryExpression ::= AssignmentExpression Operator AssignmentExpression

AssignmentExpression ::= (ParenthesisedExpression | BinaryExpression | FunctionInvocation | ArrayReferenceExpression | IncrementOrDecrementExpression | NegationExpression | LiteralExpression)

ArrayReferenceExpression ::= VariableName ArrayReference+

ArrayReference ::= OpenSquareBracket (BinaryExpression) CloseSquareBracket

IncrementOrDecrementExpression ::= LiteralExpression '++' | LiteralExpression '--' | '++' LiteralExpression | '--' LiteralExpression

NegationExpression ::= '!' LiteralExpression

AssignmentStatement ::= (ArrayReferenceExpression | VariableName) Equals (FunctionInvocation SEMICOLON| VariableInitialization)

VariableDefinition ::= StaticModifier? Type RepeatableVariable ArrayType* (SEMICOLON | (Equals VariableInitialization))

VariableName ::=  IDENTIFIER
        /*{
            implements="by.home.acs.language.psi.ACSVariableElement"
            mixin="by.home.acs.language.psi.impl.ACSVariableElementImpl"
            methods=[getName changeName getNameIdentifier getReference]
            stubClass="by.home.acs.language.stub.variable.ACSVariableStub"
        }*/

RepeatableVariable ::= VariableName (COMMA RepeatableVariable)*

VariableInitialization ::= (AssignmentExpression | SimpleInitialization) SEMICOLON

ParenthesisedExpression ::= OpenBracket AssignmentExpression CloseBracket

SimpleInitialization ::= AllTypes (COMMA RepeatableVariable Equals AllTypes)*

LiteralExpression ::= (AllTypes | VariableName)

Operator ::= (EqualityOperator | AssignmentOperator | LogicalOperator | UnaryOperator  | BitwiseOperator | ComparisonOperator | ArithmeticOperator )

AssignmentOperator ::= ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '&=' | '^=' | '|=' )

ComparisonOperator ::= ( '>=' | '<=' | '>' | '<' )

EqualityOperator ::= ( '==' | '!=')

ArithmeticOperator ::= ( '++' | '--' | '+' | '-' | '/' | '%' | '*' )

LogicalOperator ::= ( '&&' | '||' | '!' )

BitwiseOperator ::= ( '<<' | '>>' )

UnaryOperator ::= ('&' | '|' | '^' | '~')

Loops ::= ForLoop | whileLoop | untilLoop | doWhileLoop | doUntilLoop

ForLoop ::= for OpenBracket Initialization Condition Iteration CloseBracket Statement

private Initialization ::= EmptyInitialization | TypeInitialization

EmptyInitialization ::= SEMICOLON

TypeInitialization ::= StaticModifier? Type VariableList  ArithmeticInitialization* SEMICOLON

private VariableList ::= RepeatableVariable Equals (NUMBER | STRING | VariableName ) (COMMA VariableList)?//check logical type

private ArithmeticInitialization ::= ArithmeticOperator (NUMBER | STRING | VariableName)

private Condition ::= (EmptyCondition | (NormalCondition SEMICOLON) | ArithmeticCondition)

private LogicalCondition ::= ComparisonOperator

private ComparisonCondition ::= (VariableName | NUMBER | STRING) LogicalCondition (VariableName ArithmeticInitialization*| NUMBER ArithmeticInitialization* | STRING ArithmeticInitialization*) (LogicalOperator ComparisonCondition)?

NormalCondition ::= ComparisonCondition (LogicalCondition ComparisonCondition)?

private ArithmeticCondition ::= NormalCondition SEMICOLON LogicalOperator

EmptyCondition ::= SEMICOLON

private Iteration ::=  NormalIteration | EmptyIteration

EmptyIteration ::= //not sure with this...

NormalIteration ::= VariableName (ArithmeticOperator | ArithmeticOperator VariableName | VariableName AssignmentOperator (NUMBER | STRING | VariableName)) (COMMA NormalIteration)?

whileLoop ::= while OpenBracket AssignmentExpression CloseBracket Statement

untilLoop ::= until OpenBracket AssignmentExpression CloseBracket Statement

doWhileLoop ::= do Statement while OpenBracket AssignmentExpression CloseBracket SEMICOLON

doUntilLoop ::= do Statement until OpenBracket AssignmentExpression CloseBracket SEMICOLON

Type ::= (INT | STR | BOOL)

private AllTypes ::= STRING | CHARACTER | NUMBER | FLOAT | EmptyString | ArrayInitializer

EmptyString ::= '""'

ArrayType ::=  OpenSquareBracket NUMBER CloseSquareBracket

ArrayInitializer ::= OpenBrace ArrayInitializers* CloseBrace (COMMA ArrayInitializer)?

ArrayInitializers ::= ArrayInitializer | (NUMBER | STRING) (COMMA ArrayInitializers)?

ReturnOperator ::= return SEMICOLON | return BinaryExpression SEMICOLON | return VariableName SEMICOLON // Use something else but IDENTIFIER later

/**
    Control Flow Statements
 */

IfThenStatement ::= if OpenBracket AssignmentExpression CloseBracket (Statement | IfThenElseStatement)

IfThenElseStatement ::= if OpenBracket AssignmentExpression CloseBracket Statement else Statement

SwitchLoop ::= switch OpenBracket (FunctionInvocation | VariableName | NUMBER) CloseBracket OpenBrace CaseOperator* DefaultOnly? CloseBrace

CaseOperator ::=   CaseIdentifier Statement*

private DefaultOnly ::= default COLON Statement

private CaseIdentifier ::= case (VariableName | NUMBER | STRING) COLON

/*
    Key symbol's
 */
Equals ::= '='

Dot ::= '.' //not used

OpenBrace ::= '{'

CloseBrace ::= '}'

OpenBracket ::= '('

CloseBracket ::= ')'

OpenSquareBracket ::= '['

CloseSquareBracket ::= ']'

/**
    Loop Statements
 */

BreakStatement ::= break SEMICOLON

ContinueStatement ::= continue SEMICOLON

